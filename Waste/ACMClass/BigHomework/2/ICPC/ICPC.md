该程序复杂度分析大致如下:

1.提交操作 . 本质上是把一个ICPC::string 插入 std::set 中进行维护 , 用于判断该名称是否出现过.最坏时间复杂度为 $O(logn)$ .

2.开始操作 . 会进行一些些预处理 , 为一些后面会用到的数组 (std::vector) 申请空间 , 最坏时间复杂度为 $O(n)$ .我们也会把 std::set 中的元素放入一个 std::vector&lt;ICPC::string&gt;teamName中 , 下标为i的元素是队伍名称字典序大小第i+1名的队伍,而遍历一遍 std::set 最坏复杂度为 $O(n)$. 最后还需要往初始的榜单 (一个std::set&lt;int,compare&gt; scoreboard) 中插入每个队伍的编号ID(即 teamName 中对应的下标) , 每插入一个元素的最坏时间复杂度为 O(log SIZE) , SIZE为 std::set 当前元素个数,所以最坏时间复杂度为 $O(nlogn)$ . 所以整个开始操作最坏时间复杂度为 $O(nlogn)$ .

3.提交题目 . 该操作首先需要由队伍名称得到队伍 ID , 需要在 teamName 上二分查找对应的 ID , 最坏时间复杂度 $O(logn)$ . 之后,除非有通过新的题目且当前未冻结 , 否则只需简单记录数据即可 , 最坏复杂度 $O(1)$ (忽略 m = 26 的常数) .反之 , 则队伍排名可能改变 , 此时我们需要在记录数据前先把该 ID 取出 scoreboard , 在记录数据后加回去 ID , 最坏复杂度为 $O(logn)$ . 无论如何 ,最坏复杂度为 $O(logn)$ .

4.刷新榜单 . 该操作只需把 scoreboard 内的元素从小到大(即从排名小到排名大) 保存到一个 std::vector&lt;int&gt; flushedRank 中 , 下标 i 的位置记录队伍编号 i 的队伍排名 . 最坏时间复杂度为遍历一遍 std::set的时间 , $O(n)$ . (事实上 , 观察到Flush操作多达 $1000$ 次 , $1000 n logn$ 很难不 TLE,所以显然只能用线性算法)

5.封榜操作 . 该操作只需把当时的 ICPC::team 的信息存入一个 vector 且之后不更新 scoreboard 即可 , 最坏时间复杂度为 $O(n)$  (std::vector 元素复制的最坏时间复杂度)

6.滚榜操作 . 首先,将当前 ICPC::team 数据回溯到冻结前 , 用.swap() 可使最坏时间复杂度为 $O(1)$ . 之后 , 更新 scoreboard 并且模拟滚榜过程 . 具体操作为每次从 scoreboard 尾部取出一个 ID ($O(logn)$) 从小到大解冻题目, 更新该 ID 提交的状态 . 如果解冻的题目满足 : 冻结前未通过 , 冻结后通过 . 那么此时 , 将其与倒数第二名比较 , 若名次改变 , 则需要重新插回 scoreboard . 如果不会再引起排名改变 , 则这个元素不再插入 . 最后 scoreboard 只剩一个元素 . 这个操作最多进行 $n \cdot m$ 次 , 单次操作最坏 $O(log SIZE)$ , 所以整体最坏时间复杂度为 $O(nlogn)$.

7.查询排名 . 由名字到 ID 是 $O(logn)$ , 而从 flushedRank 中得到排名则是 $O(1)$ , 所以操作最坏复杂度 $O(logn)$.

8.查询提交 . 由名字到 ID 是 $O(logn)$ , 从记录的最后提交历史信息中获取信息是 $O(1)$ . 所以最坏复杂度就是 $O(logn)$.

后记:

1. 本题目 m 最大可以达到 26 ,笔者认为不应该忽略 m 对时间复杂度的影响 . 某些部分(例如Scroll)的优化并未在报告中体现 , 但可能会导致常数一个 m 数量级的差异 , 很容易让一个操作退化表观复杂度正常 , 实际不能通过.
2. 由名字得到 ID 的操作可以用 Trie 优化至最坏 $O(1)$ (常数20,实测并没有比我的ICPC::string的二分查找快多少,而且最大空间大约需要 20 * n * 63 bytes,较大)(ICPC::string 采用倒序存储,短字符串优化,压位比较(一次比较8 byte = 8 char),所以效率较高)
3. 我依然不太认可std::unordered_map , 没有手写 Custom_Hash 的应该会 FST(扣大分bushi).
4. ~~看在我总时长跑到2700多ms了,最慢点没超过500ms,下一届是不是应该安排下单点时限制最大 1.5s , 总时长最大 10s~~
