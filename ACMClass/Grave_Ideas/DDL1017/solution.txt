T1 分析:
第一问:
首先,我们可以看出,?F10表示如果runup,那么就直接结束程序。
同时,后面的B14会回到减法操作,相当于循环.
再分析循环条件,可以看出变量3和4用来控制循环次数为100次
再分析循环过程,相当于v[0]+=v[1]再v[1]+=v[2]
可以看出这是一个典型的差分机操作,通过反解我们可以得出:
每次输出的v[0]值为n^2(n为循环的次数)
所以很明显,这个程序输出就是1 ~ 100的平方.
第二问:
类似第一问,我们可以发现,v[1],v[2]是用来控制循环次数为100次
而在这个程序中,每次循环,v[0]加一,然后计算v[0]*v[0]并输出
因此,本代码其实和第一问一样,都是输出1 ~ 100的平方


时间分析:
第一问:
初始化非循环部分有5步,共5s
每次循环要经过12(非跳转)+14(跳转) = 26步
所以总共26*100 = 2600步,共2600s,
最后跳出循环前执行了3步操作,再跳10步共13步 = 13s
所以总共5+2600+13 = 2618s

第二问:
初始化非循环部分有3步,共3s
每次循环要经过13(非跳转)+15(跳转) = 28步
其中恰一次乘法,所以共 (27+60)*100 = 8700s
最后跳出循环前执行了3步操作,再跳11步共14步 = 14s
所以总共3+8700+14 =8717s


答者注:
1比2快的根本原因在于乘法与加法的悬殊差距(60倍).
在乘法远慢于加法的时候,用差分函数实现是高效的.
当然,现在的电脑貌似计算两者的差距不太大...
(实测long long类乘法时间大约为加法的1.3 ~ 2倍)



T2 :
N 0 30
N 1 2
N 2 0
N 3 1
-
L 0
L 1
S 0
?F 10
+
L 2
L 3
S 3
P 3
L 2
L 3
S 2
P 2
B 15



T3 :
N 0 10
N 1 1
N 2 5
N 3 10
N 4 32
N 5 48
N 6 24
-
L 0
L 1
S 0
?F 15
+
L 2
L 3
S 2
L 3
L 4
S 3
L 4
L 5
S 4
L 5
L 6
S 5
P 2
B 20



T4 :
N 0 90
N 1 2  #const v[1] = 2
N 2 1
N 5 1  #const v[5] = 1
N 7 313 #maximum multi-prime
/
L 0
L 1
S 3   #remainder - > v[3]
S' 4  #quotient  - > v[4]
-
L 3   #v[3] = remainder
L 5   #v[5] = 1
?F 1  #remainder == 0 jump to next
F 5   #jump out when remainder == 1
P 1
L 4
L 6   #v[6] = 0 (uninitialized)
S 0   #v[0] = v[4] = quotient
B 15  #Back to /

L 0   #start function,default '-' mode
L 1   #v[1] = 2
?F 28 #v[0] == 1 - > jump to end
+     
L 2
L 1
S 2   #v[2] += v[1]  (v[1] = 2)
*
L 2
L 2
S 3   #v[3] = v[2] * v[2]
-
L 0
L 3
?F 15 #v[3] > v[0] - > jump to prime
/
L 0
L 2   #v[2] = current prime number
S 3   #remainder - > v[3]
S' 4  #quotient  - > v[4]
-
L 3   #v[3] == remainder
L 5   #v[5] == 1
?F 1  #remainder == 0 jump to next
B 25  #back to start function
P 2
L 4
L 6   #v[6] = 0 (uninitialized)
S 0   #v[0] = v[4] = quotient
B 15  #back to /
P 0   #prime case